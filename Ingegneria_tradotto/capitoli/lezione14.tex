\chapter{Lezione 14: Bad Smell e refactoring}
\section{Bad Smells}
\subsection{Code Smells e Refactoring}
I "Code smells" (odori del codice) sono indicazioni che ci sono problemi di design nel sistema.
Le tecniche di refactoring correggono i code smells.
La maggior parte delle tecniche di refactoring sono abbastanza semplici, e spesso c'è un
ottimo supporto negli IDE (attualmente).
Sia nel caso dei code smells che delle tecniche di refactoring, ne vengono "scoperti" di nuovi
continuamente, quindi la lista dei nomi è piuttosto lunga: esamineremo un
piccolo sottoinsieme di ciascuno.
Link utili:
\begin{itemize}
\item \href{https://refactoring.com/}{https://refactoring.com/}
\item \href{https://refactoring.guru/}{https://refactoring.guru/}
\end{itemize}

\subsection{Tipi di Bad Smells: Bloaters}
I Bloaters sono codice, metodi e classi che sono
cresciuti a proporzioni così gigantesche da diventare
difficili da gestire.
Di solito, questi odori non emergono immediatamente, ma
si accumulano nel tempo mentre il programma evolve (e
soprattutto quando nessuno si sforza di eliminarli).
Esempi
\begin{itemize}
\item Metodo Lungo (Long Method)
\item Classe Grande (Large Class)
\item Ossessione Primitiva (Primitive Obsession)
\item Lista Parametri Lunga (Long Parameter List)
\item Grumi di Dati (Data Clumps)
\end{itemize}

\subsection{Tipi di Bad Smells: Abusatori della Programmazione Orientata agli Oggetti}
Tutti questi odori sono applicazioni incomplete o errate
dei principi di programmazione orientata agli oggetti.
\begin{itemize}
\item Classi Alternative con Interfacce Diverse (Alternative Classes with Different Interfaces)
\item Eredità Rifiutata (Refused Bequest)
\item Istruzioni Switch (Switch Statements)
\item Campo Temporaneo (Temporary Field)
\end{itemize}

\subsection{Tipi di Bad Smells: Impedimenti al Cambiamento}
Questi odori significano che se è necessario cambiare qualcosa
in un punto del codice, bisogna fare molti
cambiamenti anche in altri punti. Lo sviluppo del programma
diventa molto più complicato e costoso di
conseguenza.
\begin{itemize}
\item Cambiamento Divergente (Divergent Change)
\item Gerarchie di Eredità Parallele (Parallel Inheritance Hierarchies)
\item Chirurgia con Fucile a Pompa (Shotgun Surgery)
\end{itemize}

\subsection{Tipi di Bad Smells: Superflui}
Un superfluo è qualcosa di inutile e non necessario
la cui assenza renderebbe il codice più pulito, più
efficiente e più facile da capire.
\begin{itemize}
\item Commenti (Comments)
\item Codice Duplicato (Duplicate Code)
\item Classe Dati (Data Class)
\item Codice Morto (Dead Code)
\item Classe Pigra (Lazy Class)
\item Generalità Speculativa (Speculative Generality)
\end{itemize}

\subsection{Tipi di Bad Smells: Accoppiatori}
Tutti gli odori in questo gruppo contribuiscono all'eccessivo
accoppiamento tra classi o mostrano cosa succede se
l'accoppiamento è sostituito da un'eccessiva delega.
\begin{itemize}
\item Invidia delle Caratteristiche (Feature Envy)
\item Classe Libreria Incompleta (Incomplete Library Class)
\item Catene di Messaggi (Message Chains)
\item Uomo di Mezzo (Middle Man)
\end{itemize}

\section{Bad Smells e il concetto
di Debito Tecnico}
\subsection{Debito Tecnico}
Si verifica ogni volta che il codice soddisfa i requisiti funzionali ma è subottimale o "veloce
e sporco". Ad esempio:
\begin{itemize}
\item codice "maleodorante"
\item algoritmi inefficienti
\item design sciatto
\end{itemize}
Potrebbe essere corretto durante la code-review, potrebbe generare TODOs o nuovi problemi nel
sistema di tracciamento dei problemi.
Comprendere, misurare e comunicare il debito tecnico è
critico nell'industria del software.

\subsection{Debito Strategico, Intenzionale}
Esempi di debito intenzionale o strategico:
\begin{itemize}
\item Design non modulare
\item Implementazione intenzionalmente troppo semplice/troppo complessa
\item Indifferenza alle prestazioni
\item Mancanza di generalità o estensibilità
\item Mancanza di scalabilità
\end{itemize}

\subsection{Debito Non-Strategico, Non Intenzionale}
Il debito si accumula anche involontariamente, nessun processo di sviluppo è
perfetto.
Esempi di debito non intenzionale o non strategico:
\begin{itemize}
\item Bad Smells
\item Memory leaks
\item Copertura dei test insufficiente
\item Implementazione involontariamente complessa
\item Architettura rigida/fragile
\item Colli di bottiglia nelle prestazioni o nella scalabilità
\item Codice disordinato o difficile da mantenere
\end{itemize}

\subsection{Conseguenze del Debito}
Troppo debito => troppo tempo speso a pagare gli interessi.
Imprevedibilità nella fase di pianificazione del software, aumento del rischio di
investimento.
Rallenta il lavoro futuro.
Più bug, più costoso correggerli.
Sviluppatori frustrati e infelici.

\subsection{Misurare il Debito Tecnico}
Alcuni strumenti
relativi alla qualità,
come SonarQube,
possono fornire una
stima accurata del
debito tecnico
accumulato all'interno
di un repository software.

\section{Correggere i Bad Smells con
il Refactoring}
\subsection{Refactoring}
Metafora di base:
\begin{itemize}
\item Iniziare con una base di codice esistente e migliorarla.
\item Cambiare la struttura interna (dal piccolo al medio) preservando
la semantica complessiva: cioè, riorganizzare i "fattori" ma ottenere lo stesso "prodotto" finale.
\end{itemize}
L'idea è che dovresti migliorare il codice in qualche modo significativo.
Per esempio:
\begin{itemize}
\item Ridurre il codice quasi duplicato
\item Migliorare la coesione, ridurre l'accoppiamento
\item Migliorare la parametrizzazione, la comprensibilità, la manutenibilità, la flessibilità,
l'astrazione, l'efficienza, ecc...
\end{itemize}

\subsection{Il Ciclo di Refactoring}
Schema di base per il refactoring con un programma funzionante:
\begin{enumerate}
\item Scegliere l'odore peggiore
\item Selezionare un refactoring che affronterà l'odore
\item Applicare il refactoring.
\end{enumerate}
Selezionare refactoring per migliorare il codice ad ogni passaggio attraverso il ciclo.
Il comportamento del programma non viene modificato.
Quindi, il programma rimane in uno stato funzionante. Così il ciclo migliora il codice ma mantiene il comportamento.

La parte più difficile del processo: Identificare l'odore!
Quando inizi il refactoring, è meglio iniziare con le cose facili (ad esempio, suddividere grandi routine o rinominare cose per chiarezza).
Questo ti permette di vedere e correggere i problemi rimanenti più facilmente.

\subsection{Refactoring e Test Unitari}
Il refactoring dipende fortemente dall'avere una buona suite di test unitari.
Con i test unitari, possiamo fare refactoring.
Poi eseguire i test automatizzati, per verificare che il comportamento sia effettivamente preservato.
Senza buoni test unitari,
\begin{itemize}
\item gli sviluppatori potrebbero evitare il refactoring
\item A causa della paura di poter rompere qualcosa.
\end{itemize}

\subsection{Perché Dovresti Fare Refactoring?}
La realtà:
\begin{itemize}
\item Estremamente difficile ottenere il design "giusto" la prima volta
\item Difficile comprendere pienamente il dominio del problema
\item Difficile capire i requisiti dell'utente, anche se l'utente li conosce!
\item Difficile sapere come il sistema evolverà in X anni
\item Il design originale è spesso inadeguato
\item Il sistema diventa fragile nel tempo e più difficile da cambiare
\end{itemize}
Il refactoring ti aiuta a
\begin{itemize}
\item Manipolare il codice in un ambiente sicuro (preservando il comportamento)
\item Ricreare una situazione in cui l'evoluzione è possibile
\item Comprendere il codice esistente
\end{itemize}

Il refactoring migliora il design del software
\begin{itemize}
\item Senza refactoring il design del programma si deteriorerà
\item Il codice mal progettato di solito richiede più codice per fare le stesse cose, spesso
perché il codice fa la stessa cosa in luoghi diversi
\end{itemize}
Il refactoring rende il software più facile da capire. Nella maggior parte degli ambienti di sviluppo software, qualcun altro dovrà eventualmente leggere il tuo codice.
Il refactoring ti aiuta a trovare bug.
Il refactoring ti aiuta a programmare più velocemente.

\includepdf[pages=-, addtotoc={1,section,1,Refactoring tipici, L6:1, 7,subsection,1,Referenze,L6:2}]{esempi/lezione14.pdf}

\subsection{Codice Duplicato}
Se vedi la stessa struttura di codice in più di un posto, puoi essere
sicuro che il tuo programma sarà migliore se trovi un modo per unificarli.
Il problema di codice duplicato più semplice è quando hai la stessa
espressione in due metodi della stessa classe.
Esegui Extract Method (Estrai Metodo) e invoca il codice da entrambi i posti.
Un altro problema di duplicazione comune è avere la stessa espressione in
due sottoclassi sorelle.
Esegui Extract Method in entrambe le classi e poi Pull Up Field (Tira Su il Campo).
Se hai codice duplicato in due classi non correlate, considera di usare
Extract Class (Estrai Classe) in una classe e poi usa il nuovo componente nell'altra.

\subsection{Metodo Lungo}
Più lungo è una procedura, più è difficile da capire.
I programmi orientati agli oggetti vivono meglio e più a lungo con metodi brevi.
Quasi sempre, tutto ciò che devi fare per abbreviare un metodo è Extract
Method.
Se provi a usare Extract Method e finisci per passare molti parametri,
spesso puoi creare una nuova Classe che incapsuli i parametri.

\subsection{Classe Grande}
Quando una classe sta cercando di fare troppo, spesso si manifesta con troppe
variabili di istanza. Quando una classe ha troppe variabili di istanza,
il codice duplicato non può essere lontano.
Una classe con troppo codice è anche un terreno fertile per la duplicazione.
In entrambi i casi Extract Class ed Extract Subclass funzioneranno.

\subsection{Lista Parametri Lunga}
Vecchia scuola: passa tutto come parametri. Era meglio dei dati globali.
Con gli oggetti non è necessario passare tutto ciò di cui il metodo ha bisogno,
invece passi abbastanza in modo che il metodo possa accedere a tutto ciò di cui ha
bisogno.
Questo è positivo, perché le lunghe liste di parametri sono difficili da capire,
perché sono incoerenti e difficili da usare, perché le stai
cambiando continuamente quando hai bisogno di più dati.
Usa Replace Parameter with Method (Sostituisci Parametro con Metodo) quando puoi ottenere i dati in un
parametro facendo una richiesta a un oggetto che già conosci.
Usa Introduce Parameter Object (Introduci Oggetto Parametro).

\subsection{Cambiamento Divergente}
Il cambiamento divergente si verifica quando una classe viene comunemente modificata in
modi diversi per ragioni diverse. Se stai facendo questo, stai quasi certamente violando i principi di una chiave astrazione e separazione delle preoccupazioni, e dovresti fare refactoring del tuo codice.
Per sistemare questo, identifica tutto ciò che cambia per una particolare
causa e usa Extract Class per metterli tutti insieme.

\subsection{Chirurgia con Fucile a Pompa}
Questa situazione si verifica quando ogni volta che fai un tipo di cambiamento,
devi fare molti piccoli cambiamenti a molte classi diverse.
Lo stesso tasso di cambiamento in oggetti diversi, particolarmente se sono
scollegati.
Un cambiamento concettualmente semplice che richiede modifiche al codice in
molti posti. Il risultato della Programmazione Copia e Incolla.
Quando i cambiamenti sono sparsi ovunque sono difficili da trovare, ed è
facile perdere un cambiamento importante.
Vuoi usare Move Method (Sposta Metodo) e Move Field (Sposta Campo) per mettere tutti i cambiamenti in una
singola classe.
Se nessuna classe attuale sembra un buon candidato, creane una.

\subsection{Invidia delle Caratteristiche}
"L'invidia delle caratteristiche" è quando un metodo fa un uso intenso di dati e
metodi da un'altra classe.
Usa Move Method per metterlo nella classe più desiderata.
A volte solo una parte del metodo fa un uso intenso delle caratteristiche di
un'altra classe.
Usa Extract Method per estrarre quelle parti che appartengono all'altra classe.

\subsection{Grumi di Dati}
Spesso vedrai gli stessi tre o quattro elementi di dati insieme in molti
luoghi:
\begin{itemize}
\item Campi in un paio di classi
\item Parametri in molte firme di metodi
\end{itemize}
Gruppi di dati che stanno insieme dovrebbero davvero essere trasformati in
un proprio oggetto, Es.: x,y → Point.
Il primo passo è cercare dove i grumi appaiono come campi e usare
Extract Class per trasformare i grumi in un oggetto.
Per i parametri dei metodi usa Introduce Parameter Object o Preserve
Whole Object (Preserva Oggetto Intero) per snellirli.

\subsection{Ossessione Primitiva}
Le persone nuove agli oggetti sono talvolta riluttanti a usare piccoli oggetti per
piccoli compiti, come classi per soldi che combinano numeri e
valuta, intervalli con un limite superiore e inferiore, e stringhe speciali come
numeri di telefono e codici postali.
Molti programmatori sono riluttanti a introdurre classi "piccole" che
rappresentano cose facilmente rappresentate da primitivi—numeri di telefono,
codici postali, importi di denaro, intervalli (variabili con limiti superiori e
inferiori).
Se il tuo primitivo ha bisogno di dati o comportamenti aggiuntivi, considera di trasformarlo
in una classe.
Per esempio, potresti voler formattare il tuo primitivo in un modo speciale, come
(215)898-0587 o 19104-6389.

\subsection{Test di Tipo}
La maggior parte delle volte quando vedi un'istruzione switch su un tipo dovresti
considerare il polimorfismo.
Usa Extract Method per estrarre l'istruzione switch e poi Move
Method per portarla nella classe dove è necessario il polimorfismo.

\subsection{Gerarchie di Eredità Parallele}
È davvero un caso speciale di chirurgia con fucile a pompa.
In questo caso ogni volta che fai una sottoclasse di una classe, devi
fare una sottoclasse di un'altra.
Ci sono due modi per procedere. Per rimuovere il parallelo: fare refactoring di una o entrambe
le gerarchie fino a quando i loro membri sono congruenti, quindi collassarle a coppie.
Per rimuovere la duplicazione tra i paralleli: definire responsabilità distinte
raffinate da ciascuna gerarchia e riposizionare i metodi come
appropriato. -- WardCunningham.
Se usi Move Method e Move Field, la gerarchia sulla classe di riferimento
scompare.

\subsection{Classe Pigra}
Ogni classe che crei costa denaro e tempo da mantenere e
capire.
Una classe che non sta portando il suo peso dovrebbe essere eliminata.
Se hai sottoclassi che non stanno facendo abbastanza prova a usare Collapse
Hierarchy (Collassa Gerarchia) e i componenti quasi inutili dovrebbero essere sottoposti a
Inline Class (Inserisci Classe).

\subsection{Generalità Speculativa}
Ottieni questo odore quando qualcuno dice "Penso che avremo bisogno di fare questo
un giorno" e hai bisogno di ogni tipo di ganci e casi speciali per gestire cose
che non sono richieste.
Questo odore è facilmente rilevabile quando gli unici utenti di una classe o metodo sono
casi di test.
Se hai classi astratte che non stanno facendo abbastanza, usa Collapse
Hierarchy.
La delega non necessaria può essere rimossa con Inline Class.
I metodi con parametri inutilizzati dovrebbero essere soggetti a Remove Parameter
(Rimuovi Parametro).
I metodi nominati con strani nomi astratti dovrebbero essere riparati con Rename
Method (Rinomina Metodo).

\subsection{Campo Temporaneo}
A volte vedrai un oggetto in cui una variabile di istanza è impostata
solo in determinate circostanze.
Questo può rendere il codice difficile da capire perché di solito ci aspettiamo
che un oggetto usi tutte le sue variabili.
Usa Extract Class per creare una casa per queste variabili orfane mettendo
tutto il codice che usa la variabile nel componente.

\subsection{Catene di Messaggi}
Le catene di messaggi si verificano quando vedi un client che chiede a un oggetto un
altro oggetto, che il client poi chiede per un altro oggetto ancora, che
il client poi chiede per un altro oggetto ancora, ecc.: intermediate.getProvider().doSomething()
Altrimenti: 
 ch = vehicle->getChassis();
body = ch->getBody();
shell = body->getShell();
material = shell->getMaterial();
props = material->getProperties();
color = props->getColor();
Navigare in questo modo significa che il client è strutturato sulla struttura
della gerarchia.

\subsection{Middle Man}
Una delle principali caratteristiche degli Oggetti è l'incapsulamento.
L'incapsulamento spesso viene con la delega.
A volte la delega può andare troppo oltre.
Per esempio, se trovi che metà dei metodi sono delegati a un'altra classe,
potrebbe essere il momento di usare Remove Middle Man (Rimuovi Uomo di Mezzo) e parlare con l'oggetto che
realmente sa cosa sta succedendo.
Se solo pochi metodi non stanno facendo molto, usa Inline Method per incorporarli
nel chiamante.
Se c'è un comportamento aggiuntivo, puoi usare Replace Delegation with
Inheritance (Sostituisci Delega con Eredità) per trasformare l'uomo di mezzo in una sottoclasse dell'oggetto reale.

\includepdf[pages=-, addtotoc={1,subsection,1,Esempio di Middle Man, L6:3,2,section,1,Esercizi,L6:4}]{esercizi/esercizi14.pdf}